#!/usr/bin/env python
'''A themeable status bar written in Python, using xcffib.

'''
import asyncio
import os
import sys
from datetime import datetime

import xcffib
import xcffib.render
import xcffib.randr
from xcffib.randr import NotifyMask, ScreenChangeNotifyEvent

from dateutil.tz import gettz
import i3ipc
import netifaces
import statgrab

from xcffib√§r.sourcePatterns import Color
from xcffib√§r.Theme import Theme
from xcffib√§r.atoms import initAtoms
from xcffib√§r.utils import Perimeter, QuitApplication, inspect, printError, printInfo
from xcffib√§r.timers import addDelay, addInterval, triggerElapsedTimers
from xcffib√§r import Bar, chunks, FSReader, Store, Window, XSetup


TICK_LENGTH = 0.005
SCREEN_INDEX = 0


theme = Theme({
    'foreground': Color('8f8'),
    #'background': Color('222'),
    'background': Color('000c'),
    'defaultChunkStyle': {
        'foreground': Color('fff'),
        'background': Color('0000'),
        #'fontFamily': 'monospace',
        'fontFamily': 'Input Mono Narrow',
        'fontStretch': 'condensed',
    },
    'chunkStyles': {
        # Text styles
        'Text': {
            'fontSize': '11px',
            'padding': Perimeter(3, 12, 4, 4),
        },
        'title': {
            'foreground': Color('555'),
            'fontSize': '8px',
            'padding': Perimeter(6, 4, 4),
        },
        'net-address': {
            'fontSize': '11px',
        },
        'clock': {
            'foreground': Color('bbb'),
            'fontSize': '10px',
            'padding': Perimeter(4),
        },
        'clock-alt': {
            'foreground': Color('777'),
        },

        'workspace': {
            'foreground': Color('999'),
            'padding': Perimeter(3, 8, 4, 8),
        },
        'workspace-visible': {
            'foreground': Color('ddd'),
        },
        'workspace-focused': {
            'foreground': Color('f80'),
            'background': Color('0005'),
        },
        'workspace-urgent': {
            'foreground': Color('f42'),
            'background': Color('5005'),
        },

        'mode': {
            'foreground': Color('fff'),
            'background': Color('5855'),
            'fontSize': '8px',
            'padding': Perimeter(6, 8, 4),
        },
        'hidden': {
            'padding': Perimeter(0),
        },

        # Image styles
        'icon': {
            'padding': Perimeter(2, 1, 3, 1),
        },
        'icon-clock': {
            'image': '/usr/share/icons/Adwaita/16x16/apps/preferences-system-time-symbolic.symbolic.png',
            'padding': Perimeter(3, 0, 2, 1),
            'foreground': Color('448'),
        },
        'icon-net-wired': {
            'image': '/usr/share/icons/Adwaita/16x16/devices/network-wired-symbolic.symbolic.png',
            'padding': Perimeter(2, 0, 3, 1),
        },
        'icon-net-wireless': {
            'image': '/usr/share/icons/Adwaita/16x16/devices/network-wireless-symbolic.symbolic.png',
            'padding': Perimeter(2, 0, 3, 0),
        },
        'icon-info': {
            'foreground': Color('888'),
        },
        'icon-active': {
            'foreground': Color('080'),
        },
        'icon-inactive': {
            'foreground': Color('555'),
        },

        # Graph styles
        'Graph': {
            'padding': Perimeter(3),
            'trough': Color('2228'),
            'foregrounds': [
                Color('0f0'),  # user
                Color('f00'),  # kernel
                Color('00f'),  # nice
                Color('f0f'),  # swap
                Color('555'),  # iowait
            ]
        },
        'HistoryGraph': {
            'padding': Perimeter(1, 4),
            'trough': Color('0004'),
            'foregrounds': [
                Color('0f0'),  # user
                Color('f00'),  # kernel
                Color('00f'),  # nice
                Color('f0f'),  # swap
                Color('555'),  # iowait
            ]
        },
    },
})


def setupStore(store, i3conn):
    clockFormat = '%Y-%m-%d %H:%M:%S.%f'
    altTimezone = gettz('Europe/Berlin')

    def updateClock():
        store['time.local'] = datetime.now().strftime(clockFormat)[:-5]
        store['time.berlin'] = datetime.now(altTimezone).strftime(clockFormat)[:-5]
    addInterval(0.1, updateClock)

    def updateCPUStats():
        store['cpu.percents'] = statgrab.sg_get_cpu_percents()
    addInterval(0.2, updateCPUStats)

    def onWorkspaceUpdate(_i3conn, event):
        printInfo('onWorkspaceUpdate:')
        inspect(event)
        store['i3.workspaces'] = i3conn.get_workspaces()
    i3conn.on('workspace::focus', onWorkspaceUpdate)
    i3conn.on('workspace::urgent', onWorkspaceUpdate)
    i3conn.on('workspace::empty', onWorkspaceUpdate)

    def onModeChange(_i3conn, event):
        printInfo('onModeChange:')
        inspect(event)
        store['i3.mode'] = event.change
    i3conn.on('mode', onModeChange)

    def updateNetwork():
        ethernetAddresses = []
        wifiAddresses = []
        for interface in netifaces.interfaces():
            addrs = netifaces.ifaddresses(interface).get(netifaces.AF_INET)
            if addrs:
                if interface[0] == 'e':
                    ethernetAddresses.extend(addr['addr'] for addr in addrs)
                elif interface[0] == 'w':
                    wifiAddresses.extend(addr['addr'] for addr in addrs)

        store['network.addresses.ethernet'] = ethernetAddresses
        store['network.addresses.wifi'] = wifiAddresses
    addInterval(0.5, updateNetwork)

    def tempTransform(value):
        return int(value) / 1000.0
    FSReader('/sys/class/thermal/thermal_zone3/temp', 'temp.cpu.die', store, transform=tempTransform).updateEvery(0.2)
    FSReader('/sys/class/thermal/thermal_zone4/temp', 'temp.wifi', store, transform=tempTransform).updateEvery(0.2)


awaitingScreenChange = False

def setupBar(bar, store, outputs, i3conn):
    # Clock
    clock = chunks.Text(store.template('{time.local}'), styles='clock')
    clockAlt = chunks.Text(store.template('{time.berlin} (Berlin)'), styles='clock-alt clock')

    # CPU usage
    cpuHistoryGraph = chunks.HistoryGraph(maxValue=100, width=100, height=21)

    def updateCPUGraph():
        cpuHistoryGraph.values = [
            store['cpu.percents.user'],
            store['cpu.percents.kernel'],
            store['cpu.percents.nice'],
            store['cpu.percents.swap'],
            store['cpu.percents.iowait'],
        ]
    store.watch('cpu.percents', updateCPUGraph)

    # Temperature
    temperatureCPU = chunks.Text('', styles='temperature-cpu temperature')
    temperatureWiFi = chunks.Text('', styles='temperature-cpu temperature')

    def updateTemperatures():
        temperatureCPU.text = store['temp.cpu.die']
        temperatureWiFi.text = store['temp.wifi']
    store.watch('temp', updateTemperatures)

    # i3 workspaces
    def onWorkspaceClick(workspace):
        i3conn.command(f'workspace {workspace.name}')
    i3Workspaces = chunks.Switcher(
        choices=[workspace for workspace in i3conn.get_workspaces() if workspace['output'] in outputs],
        choiceStylePrefix='workspace',
        onChoiceClick=onWorkspaceClick,
    )

    def onWorkspaceUpdate():
        i3Workspaces.choices = [workspace for workspace in store['i3.workspaces'] if workspace['output'] in outputs]
        #i3Workspaces.choices = [workspace for workspace in i3conn.get_workspaces() if workspace['output'] in outputs]
    store.watch('i3.workspaces', onWorkspaceUpdate)

    # i3 mode display
    i3Mode = chunks.Text('', styles='hidden')

    def onModeChange():
        mode = store['i3.mode']
        i3Mode.text = '' if mode == 'default' else mode
        i3Mode.styles = ['hidden'] if mode == 'default' else ['mode']
    store.watch('i3.mode', onModeChange)

    # Networking
    ethernetIPText = chunks.Text('', styles='net-address')
    ethernetIcon = chunks.Image(styles='icon-net-wired icon icon-active')
    wifiIPText = chunks.Text('', styles='net-address')
    wifiIcon = chunks.Image(styles='icon-net-wireless icon icon-inactive')

    def updateNetworkAddresses():
        ethernetAddresses = store['network.addresses.ethernet']
        ethernetIPText.text = ', '.join(ethernetAddresses)
        ethernetIcon.styles = [*ethernetIcon.styles[:-1], 'icon-active' if ethernetAddresses else 'icon-inactive']

        wifiAddresses = store['network.addresses.wifi']
        wifiIPText.text = ', '.join(wifiAddresses)
        wifiIcon.styles = [*wifiIcon.styles[:-1], 'icon-active' if wifiAddresses else 'icon-inactive']
    store.watch('network.addresses', updateNetworkAddresses)

    # Bar layout
    bar.addLeft(
        i3Workspaces,
        i3Mode,
        chunks.Text('xcffib√§r', styles='title'),
    )

    #bar.addCenter(chunks.Text('xcffib√§r', styles='title'))

    bar.addRight(
        clock,
        clockAlt,
        #chunks.Image('/usr/share/icons/Moka/16x16/apps/clock.png', styles='icon'),
        chunks.Image(styles='icon-clock icon'),

        #chunks.Separator(width=8, height=18),

        ethernetIPText,
        ethernetIcon,

        #chunks.Separator(width=8, height=18),

        wifiIPText,
        wifiIcon,

        #chunks.Separator(width=8, height=18),

        cpuHistoryGraph,

        #chunks.Image(styles='icon-temperature icon'),
        chunks.Text('üå°', styles='icon'),
        temperatureCPU,
        temperatureWiFi,
    )


def handleWindowEvent(event):
    printInfo(f'Incoming {event.__class__.__name__}:')
    inspect(event)

    windowID = event.window if hasattr(event, 'window') else event.event
    Window.windowsByID[windowID].handleEvent(event)


def run():
    conn = xcffib.connect(display=os.getenv('DISPLAY'))
    conn.randr = conn(xcffib.randr.key)
    conn.render = conn(xcffib.render.key)

    screens = conn.get_screen_pointers()

    root = conn.get_setup().roots.list[SCREEN_INDEX]

    initAtoms(conn)

    depthInfo = [
        d
        for d in root.allowed_depths.list
        if d.depth == 32
    ][0]

    printInfo('depthInfo:')
    inspect(depthInfo)

    visualType = [
        v
        for v in depthInfo.visuals.list
        if v._class == xcffib.xproto.VisualClass.TrueColor  # pylint: disable=protected-access
    ][0]

    printInfo('visualType:')
    inspect(visualType)

    xSetup = XSetup(conn, screens[SCREEN_INDEX], depthInfo, visualType, theme)

    dummy = Window(xSetup)

    printInfo('GetScreenResources:')
    screenResources = conn.randr.GetScreenResources(dummy.id).reply()
    inspect(screenResources)

    statgrab.sg_init()

    i3conn = i3ipc.Connection()

    bars = []

    def paintBars():
        for bar in bars:
            bar.paint()

    store = Store(paintBars)
    setupStore(store, i3conn)

    wrappedI3Command = i3conn.command

    def i3Command(command):
        print(f'Sending i3 command: {repr(command)}')
        sys.stdout.flush()
        wrappedI3Command(command)

    i3conn.command = i3Command

    def setupBars():
        crtcInfoCookies = [(crtc, conn.randr.GetCrtcInfo(crtc, 0)) for crtc in screenResources.crtcs]
        for crtc, crtcInfoCookie in crtcInfoCookies:
            crtcInfo = crtcInfoCookie.reply()
            if crtcInfo.num_outputs:
                printInfo(f'Creating bar for crtc {crtc}.')
                outputs = [
                    conn.randr.GetOutputInfo(output, 0).reply().name.raw.decode('utf8')
                    for output in crtcInfo.outputs
                ]
                printInfo('outputs:', outputs)
                bar = Bar(xSetup, height=21, screenExtents=crtcInfo, name=outputs[0])
                setupBar(bar, store, outputs, i3conn)
                bars.append(bar)
            else:
                print(f'(crtc {crtc} disabled)')

    setupBars()

    dummy.close()

    conn.randr.SelectInput(root.root, NotifyMask.ScreenChange)

    loop = asyncio.get_event_loop()

    def handleScreenChange():
        printInfo(f'Incoming screen change event; closing and re-creating bars.')
        while bars:
            try:
                bars.pop().close()
            except Exception as error:  # pylint: disable=broad-except
                printError(f'Unexpected {error.__class__.__name__} received while closing bar:', error)
                inspect(error)
        setupBars()
        globals()['awaitingScreenChange'] = False

    def shutdown():
        printInfo('Shutting down.')
        loop.stop()

    def xcbPoll():
        while True:
            try:
                #event = conn.wait_for_event()
                event = conn.poll_for_event()
            except xcffib.ProtocolException as error:
                printError(f'Protocol error {error.__class__.__name__} received!')
                shutdown()
                break
            except Exception as error:  # pylint: disable=broad-except
                printError(f'Unexpected {error.__class__.__name__} received:', error)
                inspect(error)
                shutdown()
                break

            if conn.has_error():
                printError('Connection error received!')
                shutdown()
                break

            elif not event:
                break

            try:
                if isinstance(event, ScreenChangeNotifyEvent):
                    if not awaitingScreenChange:
                        printInfo(f'Incoming {event.__class__.__name__}; scheduling bar re-creation.')
                        globals()['awaitingScreenChange'] = True
                        addDelay(1, handleScreenChange)
                    else:
                        printInfo(f'Ignoring {event.__class__.__name__}; bar re-creation already scheduled.')
                else:
                    handleWindowEvent(event)
            except QuitApplication:
                shutdown()
                break

    #TODO: Rework timers to use `asyncio.ensure_future`
    # See: https://stackoverflow.com/questions/45419723/python-timer-with-asyncio-coroutine#45430833
    async def runTimers():
        while True:
            await asyncio.sleep(TICK_LENGTH)

            triggerElapsedTimers()

    try:
        i3conn.event_socket_setup()

        loop.add_reader(conn.get_file_descriptor(), xcbPoll)
        loop.add_reader(i3conn.sub_socket, i3conn.event_socket_poll)

        loop.create_task(runTimers())
        loop.run_forever()

    finally:
        i3conn.event_socket_teardown()

        loop.run_until_complete(loop.shutdown_asyncgens())
        loop.close()

        for window in Window.windowsByID.values():
            if hasattr(window, 'cleanUp') and callable(window.cleanUp):
                window.cleanUp()

    conn.disconnect()


run()
