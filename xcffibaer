#!/usr/bin/env python
'''A themeable status bar written in Python, using xcffib.

'''
import os
import time
from datetime import datetime

import xcffib
import xcffib.render
import xcffib.randr

import statgrab

from xcffibär.sourcePatterns import Color
from xcffibär.Theme import Theme
from xcffibär.atoms import initAtoms
from xcffibär.utils import Perimeter, QuitApplication, inspect
from xcffibär.timers import addInterval, triggerElapsedTimers
from xcffibär import Bar, chunks, Window


TICK_LENGTH = 0.005
SCREEN_INDEX = 0


theme = Theme({
    'foreground': Color('8f8'),
    'background': Color('222'),
    'defaultChunkStyle': {
        'foreground': Color('fff'),
        'background': Color('000'),
        #'fontFamily': 'monospace',
        'fontFamily': 'Input Mono',
    },
    'chunkStyles': {
        # Text styles
        'Text': {
            'fontSize': '11px',
            'padding': Perimeter(0, 12, -1, 4),
        },
        'title': {
            'foreground': Color('555'),
            'fontSize': '8px',
            'padding': Perimeter(3),
        },
        'net-address': {
            'fontSize': '11px',
        },
        'clock': {
            'foreground': Color('999'),
            'fontSize': '10px',
            'padding': Perimeter(0, 4),
        },

        # Image styles
        'icon': {
            'padding': Perimeter(0, 1, 1, 1),
        },
        'icon-clock': {
            'image': '/usr/share/icons/Adwaita/16x16/apps/preferences-system-time-symbolic.symbolic.png',
            'padding': Perimeter(1, 0, 0, 1),
            'foreground': Color('448'),
        },
        'icon-net-wired': {
            'image': '/usr/share/icons/Adwaita/16x16/devices/network-wired-symbolic.symbolic.png',
            'padding': Perimeter(0, 0, 1, 1),
        },
        'icon-net-wireless': {
            'image': '/usr/share/icons/Adwaita/16x16/devices/network-wireless-symbolic.symbolic.png',
            'padding': Perimeter(0, 0, 1, 0),
        },
        'icon-info': {
            'foreground': Color('888'),
        },
        'icon-active': {
            'foreground': Color('080'),
        },
        'icon-inactive': {
            'foreground': Color('555'),
        },

        # Graph styles
        'Graph': {
            'padding': Perimeter(3),
            'trough': Color('222'),
            'foregrounds': [
                Color('0f0'),  # user
                Color('f00'),  # kernel
                Color('00f'),  # nice
                Color('f0f'),  # swap
                Color('555'),  # iowait
            ]
        },
    },
})


def setupBar(bar):
    #bar.addChunkCenter(chunks.Text('xcffibär', styles='title'))

    clock = chunks.Text(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), styles='clock')

    def updateClock():
        clock.text = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
        bar.paint()
    addInterval(0.01, updateClock)

    cpuGraph = chunks.Graph(maxValue=100, width=100, height=17)
    cpuGraph2 = chunks.Graph(maxValue=100, width=100, height=17, align='left')

    def updateCPUGraph():
        cpuPercents = statgrab.sg_get_cpu_percents()
        values = [
            cpuPercents['user'],
            cpuPercents['kernel'],
            cpuPercents['nice'],
            cpuPercents['swap'],
            cpuPercents['iowait'],
        ]
        cpuGraph.values = values
        cpuGraph2.values = values
        bar.paint()
    addInterval(0.5, updateCPUGraph)

    bar.addLeft(
        chunks.Text('xcffibär', styles='title'),
        cpuGraph,
    )

    bar.addRight(
        clock,
        #chunks.Image('/usr/share/icons/Moka/16x16/apps/clock.png', styles='icon'),
        chunks.Image(styles='icon-clock icon'),

        #chunks.Separator(width=8, height=18),

        chunks.Text('192.168.128.98', styles='net-address'),
        chunks.Image(styles='icon-net-wired icon-active icon'),

        #chunks.Separator(width=8, height=18),

        chunks.Text(''),
        chunks.Image(styles='icon-net-wireless icon-inactive icon'),

        #chunks.Separator(width=8, height=18),

        cpuGraph2,
    )


def handleWindowEvent(event):
    print('\x1b[93mIncoming %s:\x1b[m' % (event.__class__.__name__, ))
    inspect(event)

    windowID = event.window if hasattr(event, 'window') else event.event
    Window.windowsByID[windowID].handleEvent(event)


def run():
    conn = xcffib.connect(display=os.getenv('DISPLAY'))
    conn.randr = conn(xcffib.randr.key)
    conn.render = conn(xcffib.render.key)

    screens = conn.get_screen_pointers()

    initAtoms(conn)

    rootDepth = screens[SCREEN_INDEX].root_depth
    rootVisual = screens[SCREEN_INDEX].root_visual

    depthInfo = [
        d
        for d in conn.get_setup().roots.list[SCREEN_INDEX].allowed_depths.list
        if d.depth == rootDepth
    ][0]

    visualType = [
        v
        for v in depthInfo.visuals.list
        if v.visual_id == rootVisual
    ][0]

    dummy = Window(conn, screens[SCREEN_INDEX], visualType.visual_id)

    print('GetScreenResources:')
    screenResources = conn.randr.GetScreenResources(dummy.id).reply()
    inspect(screenResources)

    statgrab.sg_init()

    crtcInfoCookies = [(crtc, conn.randr.GetCrtcInfo(crtc, 0)) for crtc in screenResources.crtcs]
    for crtc, crtcInfoCookie in crtcInfoCookies:
        crtcInfo = crtcInfoCookie.reply()
        if crtcInfo.num_outputs:
            print(f'Creating bar for crtc {crtc}.')
            setupBar(Bar(conn, screens[SCREEN_INDEX], visualType, theme, height=17, screenExtents=crtcInfo))
        else:
            print(f'(crtc {crtc} disabled)')

    dummy.close()

    while True:
        try:
            #event = conn.wait_for_event()
            event = conn.poll_for_event()
        except xcffib.ProtocolException as error:
            print("\x1b[91mProtocol error %s received!\x1b[m" % (error.__class__.__name__, ))
            break
        except Exception as error:  # pylint: disable=broad-except
            print("\x1b[91mUnexpected %s received:\x1b[m %s" % (error.__class__.__name__, error))
            inspect(error)
            break

        if event:
            try:
                handleWindowEvent(event)
            except QuitApplication:
                break

        elif conn.has_error():
            print("\x1b[91mConnection error received!\x1b[m")
            break

        else:
            time.sleep(TICK_LENGTH)

        triggerElapsedTimers()

    for window in Window.windowsByID.values():
        if hasattr(window, 'cleanUp') and callable(window.cleanUp):
            window.cleanUp()

    conn.disconnect()


run()
